OpenFurther Reference Documentation
===================================

About
-----
The following documentation applies to *OpenFurther version 1.4.0-SNAPSHOT*

Conventions
~~~~~~~~~~~

NOTE: A note

IMPORTANT: An important point

TIP: A tip

WARNING: A warning

CAUTION: A point of caution

Introduction
------------
OpenFurther is an informatics platform that supports federation and integration of data from heterogeneous and disparate data sources.

It has been deployed at the University of Utah (UU) as the Federated Utah Research and Translational Health e-Repository (FURTHeR) since August 2011 and is available for use by all U of U employees and students. OpenFurther links heterogeneous data types, including clinical, public health, biospecimen and patient-generated data; empowering researchers with the ability to assess feasibility of particular clinical research studies, export biomedical datasets for analysis, and create aggregate databases for comparative effectiveness research. With the ability to link unique individuals from these sources, OpenFurther is able to identify cohorts for clinical research.

It provides semantic and syntactic interoperability as it federates health information on-the-fly and in real-time and requires neither data extraction nor homogenization by data source partners, facilitating integration by retaining data in their native format and in their originating systems.

OpenFurther is built upon Maven, Spring, Hibernate, ServiceMix, and other open source frameworks that promote OpenFurther's code reusability and interoperability.


Architecture
------------
Loosely, OpenFurther runs as a multi-tier application. The presentation layer or front end/user-interface is served (currently) through the i2b2 web client. The logic layer is served through the ServiceMix ESB, and the database layer is served using Oracle 11g, although it can be configured for other databases as well.

User Interface
~~~~~~~~~~~~~~
OpenFurther utilizes the i2b2 web client as a front-end for querying data. The user interface has been modified to support federated querying.

image:images/figures/i2b2_ui_query_results.png[scale="75%"]

Hooking OpenFurther into i2b2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
OpenFurther utilizes a Java Servlet Filter to divert query requests to the OpenFurther backend system. The Servlet filter looks for XML messages from i2b2 that indicate a query is being run. Those XML messages are then diverted to OpenFurther where OpenFurther converts them into a OpenFurther query and runs them. All other XML messages are ignored and i2b2 is allowed to run as normal. 

NOTE: *No data is stored within i2b2, all data resides within its original location*

The Federated Query Engine (FQE)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In OpenFurther, the term "FQE" (Federated Query Engine) is broadly referred to as the set of software modules involved in the execution of a federated query.

image:images/figures/fqe.png[scale="75%"]

* A federated query written in FQL (an XML based query language) or an i2b2 query is submitted at *1*.
* Utilizing the publish-subscribe pattern, one or more data source adapters are subscribed to the Query Topic at *2*. 
* If the query is an i2b2 query, the FQE converts the i2b2 query to a federated query. 
* The FQE then posts the query to the Query Topic (*2*) and each listening data source adapter receives a copy of the query.
* Each data source adapter runs through a number of steps to initialize, process, and translate a query for a given data source (Explained below). 
* Throughout the processing, status messages are sent to a Status Queue at *3*. 
* Once results are translated to a common model, they are persisted to the In-Memory database and result count is sent to *4*.

Data Source Adapters
~~~~~~~~~~~~~~~~~~~~
Data source adapters are facades around an existing data source. Data source adapters can be entirely custom for any given implementation or they can use a pre-written adapter if their data source is already in a well-known format such as OMOP, i2b2, OpenEMR, etc

image:images/figures/data_source_adapters.png[scale="75%"]

* Data source adapters follow the chain-of-responsibility pattern. The process of adapting a query is broken down into several small steps and each output is passed on to the next step. Data source adapters typically have 4 commons steps. 

1. They are given an initialization step which allows them to determine whether or not the given data source can answer the given query. It also provides for any other initialization required throughout the process. 
2. Query translation translates the logical FQL that is not specific to any data source into data source specific language. This will vary with data sources. Some data sources will utilize SQL, other’s might be a web service. It utilizes the Metadata Repository (MDR) for translating attributes and values (e.g. logical query uses Gender but actual data source uses Sex as the attribute). It also utilizes DTS (Terminology Server) to translate from a given code (e.g. ICD9 250) to the data source’s code (e.g. 12345) 
3. The query is executed against the data source and results are returned in their native format (SQL ResultSet, XML, etc). 
4. Result translations translates the results into a common model with standardized vocabulary/terminology utilizing the Metadata Repository (MDR) and DTS (Terminology Server).

Terminology Server
~~~~~~~~~~~~~~~~~~
OpenFurther utilizes a terminology server (currently from Apelon DTS) to resolve the differences between coded values. This terminology server is responsible for storing the codes for standards as well as mappings between standards. It is also utilized to store data source specific codes (local codes) and mappings to standard namespaces (ICD9, SNOMED, CPT, etc)

Apelon DTS
^^^^^^^^^^
The Apelon DTS (Distributed Terminology System) is an integrate set of open source components that provides comprehensive terminology services in distributed application environments.

DTS Supports national and international data standards, which are a necessary foundation for comparable and interoperable health information, as well as local vocabularies.

DTS consists of

* DTS Core - the core system, database, api, etc
* DTS Editor - a GUI interface for viewing, adding, and editing concepts
* Dts Browser - a web interface for viewing concepts
* Modular Classifier - allows for extending standard ontologies

The Metadata Repository (MDR)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The MDR is responsible for storing information (artifacts) about varying data sources. This includes things like data models, attributes, attribute types, etc. It is accessed using web services.

* Home grown but follows standards
** XMI, Dublin Core
** HL7 datatypes, CDA, DDI
* Stores artifacts
** Logical models (UML), local models (UML), model mappings
** Administrative information
** Descriptive information
* Models supported
** OMOP, i2b2, local models

Terminology
-----------

Getting Started
~~~~~~~~~~~~~~~
In order to utilize the OpenFurther software, it is necessary to have terminology mappings from your desired data sources to standard terminologies. OpenFurther's i2b2 front end user interface contains an ontology based off of the recommendations of the Healthcare Information Technology Standards Panel(HITSP). For instance, HITSP recommends the use of ICD-9 codes for diagnosis and LOINC for laboratory data. These standard codes are then translated via the software, terminology server, and associated mappings to be able to resolve to a local data source's codes/terms. OpenFurther uses Apelon INC's Distributed Terminology System (DTS). It is recommended to outside organizations that desire to use the OpenFurther software to consider resourcing a dedicated terminologist or someone that has experience with controlled vocabularies and ontologies to work on managing/mapping local vocabularies/codes to their specific implementation of OpenFurther.

Why are mappings needed?
^^^^^^^^^^^^^^^^^^^^^^^
Mappings are needed because of the variations in terminology used between disparate data sources.

image:images/figures/mapping_terminology.png[scale="75%"]

Initial Steps
^^^^^^^^^^^^^
Apelon DTS provides excellent documentation and examples of how to use their terminology server software. All Apelon documentation can be found here http://apelon-dts.sourceforge.net/documents.html

Local Namespaces
++++++++++++++++
Refer to page 67 of the Apelon documentation.

Authorities
+++++++++++
Refer to page 72 of the Apelon documentation.

Association Types
+++++++++++++++++
Refer to pages 75-77 of the Apelon documentation.

Association Qualifier Types
+++++++++++++++++++++++++++
Refer to pages 80-84 of the Apelon documentation.

Property Types
++++++++++++++
Refer to pages 94-96 of the Apelon documentation.

Property Qualifier Types
++++++++++++++++++++++++
Refer to pages 99-101 of the Apelon documentation.

Adding new concepts/terms, assign properties, assosciations/mappings
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Refer to pages 119-141 of the Apelon documentation.

Also refer to the import wizard plugin http://sourceforge.net/apps/trac/apelon-dts/raw-attachment/wiki/MiscWikiFiles/importwizarduserguide-3.0.pdf

Metadata Repository (MDR)
-------------------------

Getting Started
~~~~~~~~~~~~~~~
Two important parts of the metadata repository are Query Translation and Result Translation. Data stored within the MDR is used to drive each of these processes.

image:images/figures/translating_metadata.png[scale="75%"]

Query Translation
^^^^^^^^^^^^^^^^^
The objective of a query translation is to convert the OpenFurther Query Language (FQL) query (OpenFurther's classes, attributes, and attribute values) into the physical data source's data classes, attributes, and attribute values while maintaining the integrity of the query logic.

image:images/figures/query_translation.png[scale="75%"]

The user interface, currently i2b2, is responsible for building a query. When a query is submitted to the FQE, the FQE converts i2b2's query into the FQL, an XML representation of the query (see the FQL XML Schema) that consists of logical expressions using OpenFurther's data model classes and attributes.  Class and class attribute names used in FQL are based on OpenFurther classes and attributes and can be found in the OpenFurther's Java code located here: https://github.com/openfurther/further-open-core/tree/master/ds/ds-further/src/main/java/edu/utah/further/ds/further/model/impl/domain

Coded class attribute value domains within the OpenFurther model are all based on standard terminology where demographics are SNOMED CT codes, diagnosis are ICD-9 codes, and labs are LOINC codes.  All attributes that have coded values sets also have an associated attribute that ends with the term 'NamespaceId' (namespaces are also called coding systems). This NamespaceId attribute is used to signify what coding system a particular attribute will use. For instance, raceCode=413773004 and raceCodeNamespaceId=30 would signify the SNOMED CT code for the Caucasian race.

By default, Apelon DTS reserves certain identifiers for use with standard terminologys.

.Apelon DTS Namespace Identifiers
[width="40%",frame="topbot",options="header"]
|======================
|Namespace  |Identifier
|SNOMED CT  |30
|ICD-9      |10
|LOINC      |5102
|======================

Example input and output
++++++++++++++++++++++++

.Example query translation input
[source,xml,numbered]
<query xmlns="http://further.utah.edu/core/query" 
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" rootObject="Person">
	<rootCriterion>
		<searchType>CONJUNCTION</searchType>
		<criteria>
			<searchType>SIMPLE</searchType>
			<parameters>
				<parameter xsi:type="RelationType">EQ</parameter>
				<parameter xsi:type="xs:string">
					raceNamespaceId
				</parameter>
				<parameter xsi:type="xs:long">30</parameter>
			</parameters>
		</criteria>
		<criteria>
			<searchType>SIMPLE</searchType>
			<parameters>
				<parameter xsi:type="RelationType">EQ</parameter>
				<parameter xsi:type="xs:string">race</parameter>
				<parameter xsi:type="xs:string">
					413773004
				</parameter>
			</parameters>
		</criteria>
	</rootCriterion>
	<sortCriteria />
	<aliases />
</query>

Given the above input, query translation would generate the following output

.Example query translation output
[source,xml,numbered]
<query xmlns="http://further.utah.edu/core/query" 
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" rootObject="Person">
	<rootCriterion>
		<searchType>CONJUNCTION</searchType>
		<criteria>
			<searchType>SIMPLE</searchType>
			<parameters>
				<parameter xsi:type="RelationType">EQ</parameter>
				<parameter xsi:type="xs:string">
					raceConceptId
				</parameter>
				<parameter xsi:type="xs:decimal">
					4185154
				</parameter>
			</parameters>
		</criteria>
	</rootCriterion>
	<sortCriteria />
	<aliases />
</query>

Result Translation
^^^^^^^^^^^^^^^^^^
Each data source queried by OpenFurther will respond with a result set in the platform/database specific format and need to be converted into OpenFurther's data model for final analysis and reconciliation of the returned data from each data source, ie. all the pears, oranges, and pineapples need to be converted the same kind of apples. This is the job of the query result set translations, to translate all the query results back to a common/canonical/platform-independent model, or the OpenFurther model in this case.
OpenFurther uses XQuery code to translate platform-specific result sets to the OpenFurther model implying all data is/must be converted to XML.  Converting to XML is not an extra cost since OpenFurther is a web service-centric infrastructure where messages between services are communicated via XML. Query results are no exception. Data within the MDR drives the XQuery code to translate the data source specific data model and values to the OpenFurther data model and values based on standard terminology. After the XML has been translated the data are unmarshaled back to Java objects, the OpenFurther model Java objects, where/when they are persisted to the query results database (typically the in-memory database) using Hibernate.

image:images/figures/result_translation.png[scale="75%"]


Technologies
------------
OpenFurther is built on a number of Open Source technologies

* Languages
** Java
** Groovy 
** Bash
** Python
* Development Tools
** Maven 3
** SonaType Nexus
** Eclipse
** Git
** JIRA
** Bamboo
* Service Frameworks
** Spring
** Apache Commons
** Apache CXF
** Apache Camel
* Application Servers
** Apache ServiceMix
* Testing
** JUnit
** Spock

Installing
----------
OpenFurther is provided as a VM image for download at this time. The VM can be used as a reference for installation, typically splitting out each Linux user as an individual server.

TODO: Expand this section with detailed instructions for installing on Linux and Windows

Demo System Administration
---------------------------
OpenFurther utilizes a number of different servers to run. The following instructions pertain to the demo VM of OpenFurther that is available for download. All scripts used for starting and stopping services are available within the further-open-extras repository on GitHub.

TIP: The demo version contains all of the servers as individual Linux users.

Apache HTTP Server
~~~~~~~~~~~~~~~~~~
The Apache HTTP server runs on port 80 and port 443. As root, run the following

----
service httpd start|stop
----

In-Memory Database Server
~~~~~~~~~~~~~~~~~~~~~~~~~
The HSQLDB server runs on port 9001. As root, run the following

----
/etc/init.d/hsqldb start|stop
----

Core Database Server
~~~~~~~~~~~~~~~~~~~~
NOTE: While our architecture supports different database, we've currently only tested OpenFurther on Oracle and Oracle XE

----
service oracle-xe start|stop
----

Terminology Server
~~~~~~~~~~~~~~~~~~
The terminology server (Apelon DTS) runs on port 16666 (Requires that the Oracle Database Server has started). As root, run the following

----
su - dtsdemo
dts-auto start|stop
----

Enterprise Service Bus (ESB)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
OpenFurther utilizes an ESB (Apache ServiceMix) to run application code. The ESB requires that the in-memory database, core database, and terminology server are already started. As root, run the following

----
su - esb
start_esb
----

To stop the ESB:

----
su - esb
esbl
further@localhost’s password:
further@local> shutdown
Confirm: shutdown instance local (yes/no):
----

Logging Locations
~~~~~~~~~~~~~~~~~

Apache HTTP Server
^^^^^^^^^^^^^^^^^^
The Apache HTTP server logs are located in /var/www/httpd/

In-Memory Database Server
^^^^^^^^^^^^^^^^^^^^^^^^^
The HSQLDB is currently not configured for logging

Core Database Server
^^^^^^^^^^^^^^^^^^^^
The Oracle XE database server is currently not configured for logging

Terminology Server
^^^^^^^^^^^^^^^^^^
The Apelon DTS server logs in /home/demodts/Apelon_DTS/dts/bin/logs

Enterprise Service Bus (ESB)
^^^^^^^^^^^^^^^^^^^^^^^^^^^
ServiceMix ESB logs in /home/esb/servicemix/data/log

OpenFurther-i2b2
^^^^^^^^^^^^^^^^
FURTHeR-i2b2 logs in 2 different locations

* jboss: /home/i2b2/jboss/server/default/logs
* tomcat: /home/i2b2/tomcat/logs
